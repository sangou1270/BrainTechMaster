# 정렬 알고리즘

정렬 알고리즘은 데이터를 특정 순서(오름차순, 내림차순 등)로 배열하는 알고리즘입니다. 정렬은 검색, 병합 등 다른 알고리즘의 기초가 되기 때문에 매우 중요합니다.

## 목차
- [[정렬 알고리즘#버블 정렬 Bubble Sort|버블 정렬 (Bubble Sort)]]
- [[정렬 알고리즘#퀵 정렬 Quick Sort|퀵 정렬 (Quick Sort)]]
- [[정렬 알고리즘#기타 중요한 정렬 알고리즘|기타 중요한 정렬 알고리즘]]

## 버블 정렬 (Bubble Sort)

**개념**: 버블 정렬은 인접한 두 요소를 비교하여 필요시 교환하며 정렬하는 간단한 알고리즘입니다.

**동작 원리**:
1. 배열의 첫 번째 요소부터 시작하여 인접한 요소와 비교합니다.
2. 현재 요소가 다음 요소보다 크면 두 요소를 교환합니다.
3. 배열의 끝까지 이 작업을 반복하면 가장 큰 요소가 배열의 끝으로 이동합니다.
4. 이 과정을 배열이 정렬될 때까지 반복합니다.

**시간 복잡도**:
- 최선/평균/최악의 경우: O(n²)
- 최적화된 버블 정렬(정렬 여부 확인)의 최선의 경우: O(n)

**공간 복잡도**: O(1) - 추가 메모리를 거의 사용하지 않는 제자리 정렬입니다.

**장점**:
- 구현이 매우 간단합니다.
- 작은 데이터셋에 대해 효율적일 수 있습니다.
- 안정적인 정렬(같은 값을 가진 요소들의 상대적 순서 유지)입니다.
- 정렬 과정을 시각적으로 이해하기 쉽습니다.

**단점**:
- 대규모 데이터셋에 매우 비효율적입니다.
- 다른 정렬 알고리즘에 비해 교환 연산이 많습니다.

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

print(bubble_sort([64, 34, 25, 12, 22, 11, 90]))  # [11, 12, 22, 25, 34, 64, 90]
```

**최적화된 버블 정렬**:
```python
def optimized_bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:  # 교환이 없으면 이미 정렬된 상태
            break
    return arr
```

**활용 사례**:
- 교육용: 정렬 알고리즘의 기본 개념을 이해하는 데 사용됩니다.
- 거의 정렬된 작은 배열에서 효율적일 수 있습니다.
- 메모리 제약이 심한 환경에서 사용될 수 있습니다.

## 퀵 정렬 (Quick Sort)

**개념**: 퀵 정렬은 분할 정복(Divide and Conquer) 방식을 사용하는 효율적인 정렬 알고리즘입니다. 피벗(pivot)을 선택하고 피벗을 기준으로 배열을 분할하여 정렬합니다.

**동작 원리**:
1. 배열에서 피벗 요소를 선택합니다(일반적으로 첫 번째, 마지막, 또는 중간 요소).
2. 피벗보다 작은 요소는 왼쪽, 큰 요소는 오른쪽으로 재배치합니다.
3. 분할된 두 하위 배열에 대해 재귀적으로 퀵 정렬을 적용합니다.
4. 분할된 배열의 크기가 1 이하일 때 재귀가 종료됩니다.

**시간 복잡도**:
- 평균 케이스: O(n log n)
- 최악의 케이스: O(n²) (이미 정렬된 배열에서 끝 요소를 피벗으로 선택할 때)
- 최선의 케이스: O(n log n)

**공간 복잡도**:
- 평균적으로 O(log n)의 재귀 호출 스택 공간을 사용합니다.
- 최악의 경우 O(n)의 스택 공간을 사용할 수 있습니다.

**장점**:
- 평균적으로 다른 O(n log n) 정렬 알고리즘보다 빠릅니다.
- 추가 메모리 공간을 적게 사용합니다.
- 캐시 효율성이 좋습니다.
- 제자리 정렬이 가능합니다.

**단점**:
- 최악의 경우 성능이 O(n²)로 저하됩니다.
- 안정적인 정렬이 아닙니다(같은 값을 가진 요소들의 상대적 순서가 바뀔 수 있음).
- 이미 정렬된 데이터에서는 비효율적일 수 있습니다.

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

print(quick_sort([64, 34, 25, 12, 22, 11, 90]))  # [11, 12, 22, 25, 34, 64, 90]
```

**개선된 퀵 정렬 (제자리 정렬)**:
```python
def in_place_quick_sort(arr, low, high):
    if low < high:
        pivot_index = partition(arr, low, high)
        in_place_quick_sort(arr, low, pivot_index - 1)
        in_place_quick_sort(arr, pivot_index + 1, high)
    return arr

def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

# 사용 예:
# arr = [64, 34, 25, 12, 22, 11, 90]
# in_place_quick_sort(arr, 0, len(arr) - 1)
```

**활용 사례**:
- 대규모 데이터셋 정렬에 효율적입니다.
- 프로그래밍 언어의 내장 정렬 함수 구현(예: C++의 `std::sort`)에 사용됩니다.
- 데이터베이스 시스템의 정렬 연산에 활용됩니다.
- 다양한 응용 프로그램에서 가장 널리 사용되는 정렬 알고리즘 중 하나입니다.

## 기타 중요한 정렬 알고리즘

### 병합 정렬 (Merge Sort)
- **시간 복잡도**: 항상 O(n log n)
- **공간 복잡도**: O(n)
- **특징**: 안정적인 정렬, 분할 정복 방식, 연결 리스트 정렬에 효율적
- **자세한 설명**: [[병합 정렬|병합 정렬 상세 설명]]

### 힙 정렬 (Heap Sort)
- **시간 복잡도**: 항상 O(n log n)
- **공간 복잡도**: O(1)
- **특징**: 제자리 정렬, 불안정 정렬, 최대/최소 값을 빠르게 찾을 수 있음
- **자세한 설명**: [[힙 정렬|힙 정렬 상세 설명]]

### 계수 정렬 (Counting Sort)
- **시간 복잡도**: O(n + k) (k는 최대값)
- **공간 복잡도**: O(k)
- **특징**: 비교 기반이 아님, 정수 또는 유한한 범위의 데이터에만 적용 가능
- **자세한 설명**: [[계수 정렬|계수 정렬 상세 설명]]

### 기수 정렬 (Radix Sort)
- **시간 복잡도**: O(d * (n + k)) (d는 자릿수, k는 기수)
- **공간 복잡도**: O(n + k)
- **특징**: 비교 기반이 아님, 다중 키 정렬에 효율적
- **자세한 설명**: [[기수 정렬|기수 정렬 상세 설명]]

## 정렬 알고리즘 비교표

| 알고리즘 | 시간 복잡도(평균) | 시간 복잡도(최악) | 공간 복잡도 | 안정성 | 제자리 정렬 |
|---------|----------------|----------------|-----------|-------|-----------|
| 버블 정렬 | O(n²) | O(n²) | O(1) | 안정 | 예 |
| 선택 정렬 | O(n²) | O(n²) | O(1) | 불안정 | 예 |
| 삽입 정렬 | O(n²) | O(n²) | O(1) | 안정 | 예 |
| 퀵 정렬 | O(n log n) | O(n²) | O(log n) | 불안정 | 예 |
| 병합 정렬 | O(n log n) | O(n log n) | O(n) | 안정 | 아니오 |
| 힙 정렬 | O(n log n) | O(n log n) | O(1) | 불안정 | 예 |
| 계수 정렬 | O(n + k) | O(n + k) | O(k) | 안정 | 아니오 |
| 기수 정렬 | O(d(n + k)) | O(d(n + k)) | O(n + k) | 안정 | 아니오 |

## 관련 알고리즘
- [[자료구조]] - 정렬이 적용되는 기본 자료구조
- [[탐색 알고리즘]] - 정렬된 데이터에서 더 효율적인 탐색 가능

#정렬 #알고리즘 #버블정렬 #퀵정렬 #병합정렬 #힙정렬 #코딩테스트 #초급 #중급 